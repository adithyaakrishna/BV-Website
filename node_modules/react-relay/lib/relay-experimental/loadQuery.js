/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @emails oncall+relay
 */
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var React = require('react');

var invariant = require("fbjs/lib/invariant");

var _require = require('relay-runtime'),
    PreloadableQueryRegistry = _require.PreloadableQueryRegistry,
    ReplaySubject = _require.ReplaySubject,
    createOperationDescriptor = _require.createOperationDescriptor,
    getRequest = _require.getRequest,
    Observable = _require.Observable;

var LOAD_QUERY_AST_MAX_TIMEOUT = 30 * 1000;
var RenderDispatcher = null;

function useTrackLoadQueryInRender() {
  if (RenderDispatcher === null) {
    var _React$__SECRET_INTER, _React$__SECRET_INTER2;

    // Flow does not know of React internals (rightly so), but we need to
    // ensure here that this function isn't called inside render.
    RenderDispatcher = // $FlowFixMe[prop-missing]
    (_React$__SECRET_INTER = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER === void 0 ? void 0 : (_React$__SECRET_INTER2 = _React$__SECRET_INTER.ReactCurrentDispatcher) === null || _React$__SECRET_INTER2 === void 0 ? void 0 : _React$__SECRET_INTER2.current;
  }
}

function loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {
  var _React$__SECRET_INTER3, _React$__SECRET_INTER4, _options$fetchPolicy;

  // Flow does not know of React internals (rightly so), but we need to
  // ensure here that this function isn't called inside render.
  var CurrentDispatcher = // $FlowFixMe[prop-missing]
  (_React$__SECRET_INTER3 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React$__SECRET_INTER3 === void 0 ? void 0 : (_React$__SECRET_INTER4 = _React$__SECRET_INTER3.ReactCurrentDispatcher) === null || _React$__SECRET_INTER4 === void 0 ? void 0 : _React$__SECRET_INTER4.current;
  !(RenderDispatcher == null || CurrentDispatcher !== RenderDispatcher) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: `loadQuery` (or `loadEntryPoint`) should not be called inside a React render function.') : invariant(false) : void 0;
  var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';

  var networkCacheConfig = _objectSpread({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig, {
    force: true
  });

  var madeNetworkRequest = false;

  var makeNetworkRequest = function makeNetworkRequest(params) {
    // N.B. this function is called synchronously or not at all
    // madeNetworkRequest is safe to rely on in the returned value
    madeNetworkRequest = true;
    var network = environment.getNetwork();
    var sourceObservable = network.execute(params, variables, networkCacheConfig);
    var subject = new ReplaySubject();
    sourceObservable.subscribe({
      error: function error(err) {
        subject.error(err);
      },
      next: function next(data) {
        subject.next(data);
      },
      complete: function complete() {
        subject.complete();
      }
    });
    return Observable.create(function (sink) {
      return subject.subscribe(sink);
    });
  };

  var normalizationSubject = new ReplaySubject();
  var returnedObservable = Observable.create(function (sink) {
    return normalizationSubject.subscribe(sink);
  });
  var unsubscribeFromExecute;
  var retainReference;

  var executeWithSource = function executeWithSource(operation, sourceObservable) {
    retainReference = environment.retain(operation);

    var _environment$executeW = environment.executeWithSource({
      operation: operation,
      source: sourceObservable
    }).subscribe({
      error: function error(err) {
        normalizationSubject.error(err);
      },
      next: function next(data) {
        normalizationSubject.next(data);
      },
      complete: function complete() {
        normalizationSubject.complete();
      }
    });

    unsubscribeFromExecute = _environment$executeW.unsubscribe;
  };

  var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {
    var operation = createOperationDescriptor(concreteRequest, variables);
    var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';

    if (shouldFetch) {
      var source = makeNetworkRequest(concreteRequest.params);
      executeWithSource(operation, source);
    } // if the fetch policy allows fulfillment from the store and the environment
    // has the appropriate data, we do nothing.

  };

  var params;
  var loadQueryAstTimeoutId;
  var cancelOnLoadCallback;
  var moduleId;

  if (preloadableRequest.kind === 'PreloadableConcreteRequest') {
    var preloadableConcreteRequest = preloadableRequest;
    params = preloadableConcreteRequest.params;
    var _params = params;
    moduleId = _params.id;
    !(moduleId !== null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : invariant(false) : void 0;

    var _module = PreloadableQueryRegistry.get(moduleId);

    if (_module != null) {
      checkAvailabilityAndExecute(_module);
    } else {
      // If the module isn't synchronously available, we launch the network request
      // immediately and ignore the fetch policy.
      var source = makeNetworkRequest(params);

      var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad(moduleId, function (preloadedModule) {
        clearTimeout(loadQueryAstTimeoutId);
        cancelOnLoadCallback();
        var operation = createOperationDescriptor(preloadedModule, variables);
        executeWithSource(operation, source);
      });

      cancelOnLoadCallback = _PreloadableQueryRegi.dispose;
      loadQueryAstTimeoutId = setTimeout(function () {
        cancelOnLoadCallback();
        var onError = options === null || options === void 0 ? void 0 : options.onQueryAstLoadTimeout;
        var error = new Error("Relay: Query AST did not load in time for preloadable query ".concat(params.name));

        if (onError) {
          onError(error);
        } else {
          throw error;
        }
      }, LOAD_QUERY_AST_MAX_TIMEOUT);
    }
  } else {
    var graphQlTaggedNode = preloadableRequest;
    var request = getRequest(graphQlTaggedNode);
    params = request.params;
    var _params2 = params;
    moduleId = _params2.id;
    !(moduleId !== null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : invariant(false) : void 0;
    checkAvailabilityAndExecute(request);
  }

  return {
    kind: 'PreloadedQuery',
    environment: environment,
    environmentProviderOptions: environmentProviderOptions,
    dispose: function dispose() {
      unsubscribeFromExecute && unsubscribeFromExecute();
      retainReference && retainReference.dispose();
      cancelOnLoadCallback && cancelOnLoadCallback();
      loadQueryAstTimeoutId != null && clearTimeout(loadQueryAstTimeoutId);
    },
    id: moduleId,
    name: params.name,
    networkCacheConfig: networkCacheConfig,
    fetchPolicy: fetchPolicy,
    source: madeNetworkRequest ? returnedObservable : undefined,
    variables: variables
  };
}

module.exports = {
  loadQuery: loadQuery,
  useTrackLoadQueryInRender: useTrackLoadQueryInRender
};