/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails oncall+relay
 * 
 * @format
 */
// flowlint ambiguous-object-type:error
'use strict';

var invariant = require("fbjs/lib/invariant");

var useLazyLoadQueryNode = require('./useLazyLoadQueryNode');

var useMemoOperationDescriptor = require('./useMemoOperationDescriptor');

var useRelayEnvironment = require('./useRelayEnvironment');

var warning = require("fbjs/lib/warning");

var _require = require('./loadQuery'),
    useTrackLoadQueryInRender = _require.useTrackLoadQueryInRender;

var _require2 = require('react'),
    useDebugValue = _require2.useDebugValue;

var _require3 = require('relay-runtime'),
    fetchQueryDeduped = _require3.__internal.fetchQueryDeduped;

function usePreloadedQuery(gqlQuery, preloadedQuery, options) {
  // We need to use this hook in order to be able to track if
  // loadQuery was called during render
  useTrackLoadQueryInRender();
  var environment = useRelayEnvironment();
  var fetchPolicy = preloadedQuery.fetchPolicy,
      source = preloadedQuery.source,
      variables = preloadedQuery.variables;
  var operation = useMemoOperationDescriptor(gqlQuery, variables);
  var useLazyLoadQueryNodeParams;

  if (preloadedQuery.kind === 'PreloadedQuery_DEPRECATED') {
    var fetchKey = preloadedQuery.fetchKey;
    !(operation.request.node.params.name === preloadedQuery.name) ? process.env.NODE_ENV !== "production" ? invariant(false, 'usePreloadedQuery(): Expected data to be prefetched for query `%s`, ' + 'got prefetch results for query `%s`.', operation.request.node.params.name, preloadedQuery.name) : invariant(false) : void 0;
    useLazyLoadQueryNodeParams = {
      componentDisplayName: 'usePreloadedQuery()',
      fetchKey: fetchKey,
      fetchObservable: fetchQueryDeduped(environment, operation.request.identifier, function () {
        if (environment === preloadedQuery.environment && source != null) {
          return environment.executeWithSource({
            operation: operation,
            source: source
          });
        } else {
          return environment.execute({
            operation: operation
          });
        }
      }),
      fetchPolicy: fetchPolicy,
      query: operation,
      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
    };
  } else {
    // Here, we are calling fetchQueryDeduped, which usually ensures that only
    // a single network request is active for a given (environment, identifier) pair.
    // If no network request is active, it will call the third argument and initiate
    // a network request.
    //
    // However, if preloadedQuery.kind === 'PreloadedQuery', the network request (if
    // it exists) has already been made.
    //
    // Thus, if two calls to loadQuery are made with the same environment and identifier
    // (i.e. the same request is made twice), the second query will be deduped
    // and components will suspend for the duration of the first query.
    var dedupedSource = fetchQueryDeduped(environment, operation.request.identifier, function () {
      if (source && environment === preloadedQuery.environment) {
        return source;
      } else {
        // if a call to loadQuery is made with a particular environment, and that
        // preloaded query is passed to usePreloadedQuery in a different environmental
        // context, we cannot re-use the existing preloaded query. Instead, we must
        // re-execute the query with the new environment (at render time.)
        // TODO T68036756 track occurences of this warning and turn it into a hard error
        process.env.NODE_ENV !== "production" ? warning(false, 'usePreloadedQuery(): usePreloadedQuery was passed a preloaded query ' + 'that was created with a different environment than the one that is currently ' + 'in context. In the future, this will become a hard error.') : void 0;
        return environment.execute({
          operation: operation
        });
      }
    });
    useLazyLoadQueryNodeParams = {
      componentDisplayName: 'usePreloadedQuery()',
      fetchObservable: dedupedSource,
      fetchPolicy: fetchPolicy,
      query: operation,
      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
    };
  }

  var data = useLazyLoadQueryNode(useLazyLoadQueryNodeParams);

  if (process.env.NODE_ENV !== "production") {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useDebugValue({
      query: preloadedQuery.name,
      variables: preloadedQuery.variables,
      data: data,
      fetchKey: preloadedQuery.kind === 'PreloadedQuery_DEPRECATED' ? preloadedQuery.fetchKey : undefined,
      fetchPolicy: fetchPolicy,
      renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
    });
  }

  return data;
}

module.exports = usePreloadedQuery;